2025-11-18 11:57:43,356 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 11:57:44,380 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 11:59:04,792 - INFO - utils.llms - llms.py:76 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 11:59:38,149 - INFO - utils.llms - llms.py:80 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 11:59:52,528 - INFO - utils.llms - llms.py:84 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:00:55,076 - INFO - utils.llms - llms.py:88 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:02:42,705 - INFO - utils.llms - llms.py:88 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:03:35,123 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:04:20,408 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:05:01,246 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:05:39,928 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:05:41,437 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:05:47,609 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:05:49,658 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:06:19,204 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:06:55,917 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:06:57,551 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:04,285 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:07:06,305 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:08,505 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:08,507 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:09,259 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:09,446 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:09,889 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:10,065 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:10,554 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:10,608 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:11,313 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:12,498 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:16,390 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:16,698 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:17,107 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:18,973 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:07:44,320 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:08:19,093 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:08:21,836 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:08:26,584 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:08:27,460 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:08:29,000 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:08:34,069 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:08:35,648 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:08:36,418 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:08:41,942 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:08:46,952 - INFO - retrievers.graph_rag_retriever - graph_rag_retriever.py:58 - üîç Executing GraphRAG query for: Across all three RFPs, list the top five digital capabilities the companies demand and explain why those capabilities matter to their industries.
2025-11-18 12:08:47,318 - ERROR - retrievers.graph_rag_retriever - graph_rag_retriever.py:78 - Failed to search via vector retrieve: None
2025-11-18 12:08:55,412 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:02,193 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:04,115 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:04,804 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:26,277 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:28,693 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:28,897 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:34,529 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:35,600 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2305 - In advanced GraphRAG wit mode = hybrid
2025-11-18 12:09:38,622 - ERROR - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2346 - Error in hybrid advanced GraphRAG retrieval: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'db' because this database does not exist}
2025-11-18 12:09:38,723 - ERROR - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2349 - Error in hybrid advanced GraphRAG retrieval: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'db' because this database does not exist}. None
2025-11-18 12:09:41,038 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:41,080 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:44,564 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:44,618 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:45,077 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:47,025 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:51,798 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:53,882 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:55,828 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:58,368 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:09:59,758 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:10:04,033 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:12:53,067 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[1]: TimeoutError()
2025-11-18 12:12:55,316 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:12:55,447 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:12:57,258 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:12:57,398 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:12:59,046 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:12:59,370 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:13:05,319 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:23:51,331 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:23:52,363 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:24:05,264 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:24:20,322 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:24:21,215 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:23,251 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:24:24,914 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:26,960 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:27,008 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:27,460 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:27,470 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:28,175 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:28,188 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:30,118 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:30,634 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:31,863 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:31,864 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:34,423 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:34,931 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:35,446 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:24:36,587 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:25:57,329 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:26:09,042 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:26:12,010 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:26:14,579 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:26:15,705 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:26:21,123 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:26:23,650 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:26:25,631 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:26:27,754 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:26:34,124 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:26:35,671 - INFO - retrievers.graph_rag_retriever - graph_rag_retriever.py:58 - üîç Executing GraphRAG query for: Across all three RFPs, list the top five digital capabilities the companies demand and explain why those capabilities matter to their industries.
2025-11-18 12:26:35,760 - ERROR - retrievers.graph_rag_retriever - graph_rag_retriever.py:78 - Failed to search via vector retrieve: None
2025-11-18 12:26:44,472 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:26:53,114 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:26:53,690 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:26:55,877 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:27:26,314 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:27:28,306 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:27:32,088 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:27:35,569 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:27:36,310 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2305 - In advanced GraphRAG wit mode = hybrid
2025-11-18 12:27:36,949 - ERROR - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2346 - Error in hybrid advanced GraphRAG retrieval: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'db' because this database does not exist}
2025-11-18 12:27:36,982 - ERROR - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2349 - Error in hybrid advanced GraphRAG retrieval: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'db' because this database does not exist}. None
2025-11-18 12:27:39,358 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:27:43,045 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:27:43,391 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:27:45,297 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:27:50,929 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:30:38,050 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[1]: TimeoutError()
2025-11-18 12:30:39,882 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:30:40,131 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:30:40,327 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:30:42,519 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:30:44,652 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:30:47,877 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:30:51,256 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:30:51,319 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:30:52,895 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:30:53,611 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:30:55,250 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:31:00,882 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:33:50,370 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[0]: TimeoutError()
2025-11-18 12:49:45,131 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:49:59,019 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 12:50:09,240 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:50:12,133 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:50:13,938 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:50:17,931 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:50:19,865 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:50:22,416 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:50:23,676 - INFO - retrievers.graph_rag_retriever - graph_rag_retriever.py:58 - üîç Executing GraphRAG query for: Across all three RFPs, list the top five digital capabilities the companies demand and explain why those capabilities matter to their industries.
2025-11-18 12:50:23,715 - ERROR - retrievers.graph_rag_retriever - graph_rag_retriever.py:78 - Failed to search via vector retrieve: None
2025-11-18 12:50:30,104 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:50:31,340 - INFO - retrievers.graph_rag_retriever - graph_rag_retriever.py:58 - üîç Executing GraphRAG query for: Summarise the ESG‚Äêrelated banking expectations each company expresses. How do they differ between an energy developer, a consultancy, and an airline‚Äëstartup?
2025-11-18 12:50:31,365 - ERROR - retrievers.graph_rag_retriever - graph_rag_retriever.py:78 - Failed to search via vector retrieve: None
2025-11-18 12:50:37,591 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:50:39,741 - INFO - retrievers.graph_rag_retriever - graph_rag_retriever.py:58 - üîç Executing GraphRAG query for: Identify every mention of regulatory, KYC, or sanctions compliance and produce a single consolidated risk checklist.
2025-11-18 12:50:39,763 - ERROR - retrievers.graph_rag_retriever - graph_rag_retriever.py:78 - Failed to search via vector retrieve: None
2025-11-18 12:50:41,511 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:50:48,474 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:50:58,901 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:01,243 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:03,526 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:06,008 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:09,802 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:10,312 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2305 - In advanced GraphRAG wit mode = hybrid
2025-11-18 12:51:10,831 - ERROR - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2346 - Error in hybrid advanced GraphRAG retrieval: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'db' because this database does not exist}
2025-11-18 12:51:10,846 - ERROR - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2349 - Error in hybrid advanced GraphRAG retrieval: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'db' because this database does not exist}. None
2025-11-18 12:51:11,348 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2305 - In advanced GraphRAG wit mode = hybrid
2025-11-18 12:51:11,892 - ERROR - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2346 - Error in hybrid advanced GraphRAG retrieval: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'db' because this database does not exist}
2025-11-18 12:51:11,902 - ERROR - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2349 - Error in hybrid advanced GraphRAG retrieval: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'db' because this database does not exist}. None
2025-11-18 12:51:12,405 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2305 - In advanced GraphRAG wit mode = hybrid
2025-11-18 12:51:12,918 - ERROR - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2346 - Error in hybrid advanced GraphRAG retrieval: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'db' because this database does not exist}
2025-11-18 12:51:12,928 - ERROR - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2349 - Error in hybrid advanced GraphRAG retrieval: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'db' because this database does not exist}. None
2025-11-18 12:51:17,568 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:51:19,706 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:51:21,261 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 12:51:25,561 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:25,570 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:25,722 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:26,298 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:26,442 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:26,822 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:27,347 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:27,562 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:28,629 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:35,093 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:36,039 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:36,524 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:37,927 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:38,164 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:38,397 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:38,462 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:39,986 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:41,711 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:44,591 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:47,813 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:53,115 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:56,029 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:57,221 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:58,342 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:51:59,042 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:00,587 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:01,240 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:01,980 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:02,046 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:02,114 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:04,292 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:05,964 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:24,672 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:25,564 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:25,747 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:26,511 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:33,342 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:35,327 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:35,544 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:41,324 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:52:47,347 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:54:54,195 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[0]: TimeoutError()
2025-11-18 12:54:58,373 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:54:58,409 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:54:58,779 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:54:59,304 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:54:59,871 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:00,664 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:01,812 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:04,650 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:05,680 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:08,992 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:13,727 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:15,571 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:17,408 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:17,687 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:19,901 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:22,830 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:32,759 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:40,371 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:43,057 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:55:50,798 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:02,593 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:05,070 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:05,074 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:05,171 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:05,196 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:05,274 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:05,426 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:07,933 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:08,000 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:08,849 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:09,211 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:09,220 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:09,468 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:09,504 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:09,737 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:11,059 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:11,988 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:12,285 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:17,833 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:18,041 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:56:21,929 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:03,680 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[0]: TimeoutError()
2025-11-18 12:59:04,893 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:04,895 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:04,959 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:05,000 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:05,020 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:05,155 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:05,436 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:05,608 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:05,682 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:07,493 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:07,964 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:08,028 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:08,178 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:08,355 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:10,253 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:16,212 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:18,965 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:24,074 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:26,287 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:26,294 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:26,342 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:26,344 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:26,507 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:26,628 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:28,800 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:29,032 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:29,071 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:29,076 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:29,086 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:29,286 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:30,809 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:31,150 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:31,485 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:32,018 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:33,121 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:38,316 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:42,757 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 12:59:44,962 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:25,212 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[0]: TimeoutError()
2025-11-18 13:02:27,531 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:27,572 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:27,588 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:27,607 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:28,047 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:28,288 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:29,923 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:30,556 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:31,160 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:32,398 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:32,433 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:33,053 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:33,281 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:33,487 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:33,947 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:34,362 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:34,455 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:35,709 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:40,905 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:42,112 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 13:02:46,403 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 14:59:33,726 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:00:19,888 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:01:35,227 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:02:57,284 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:05:23,009 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:06:37,478 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:06:53,849 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:06:56,309 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:08:13,107 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:08:29,230 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:08:32,625 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:08:35,408 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:08:39,152 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:08:41,623 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:08:44,559 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:08:46,298 - INFO - retrievers.graph_rag_retriever - graph_rag_retriever.py:58 - üîç Executing GraphRAG query for: Across all three RFPs, list the top five digital capabilities the companies demand and explain why those capabilities matter to their industries.
2025-11-18 15:08:46,638 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:08:56,011 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:08:57,664 - INFO - retrievers.graph_rag_retriever - graph_rag_retriever.py:58 - üîç Executing GraphRAG query for: Summarise the ESG‚Äêrelated banking expectations each company expresses. How do they differ between an energy developer, a consultancy, and an airline‚Äëstartup?
2025-11-18 15:08:57,922 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:09:05,529 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:09:07,156 - INFO - retrievers.graph_rag_retriever - graph_rag_retriever.py:58 - üîç Executing GraphRAG query for: Identify every mention of regulatory, KYC, or sanctions compliance and produce a single consolidated risk checklist.
2025-11-18 15:09:07,495 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:09:14,037 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:09:17,126 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:09:22,450 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:09:25,437 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:09:28,016 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:09:33,838 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:09:34,349 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2305 - In advanced GraphRAG wit mode = hybrid
2025-11-18 15:09:36,103 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 6, column: 34, offset: 277} for query: "\n                MATCH (e:__Entity__)\n                OPTIONAL MATCH (c:Chunk)-[:HAS_ENTITY]->(e)\n                WITH e, collect(DISTINCT c.id) as text_unit_ids, count(c) as mention_count\n                WITH e, text_unit_ids, mention_count, \n                     CASE WHEN e.communityId IS NOT NULL THEN e.communityId ELSE [] END as community_ids\n                OPTIONAL MATCH (e)-[r:RELATED_TO]-()\n                WITH e, text_unit_ids, mention_count, community_ids, count(r) as relationship_count\n                RETURN e.id as id,\n                       e.name as title,\n                       coalesce(e.entity_type, [l IN labels(e) WHERE l <> '__Entity__'][0]) as type,\n                       e.description as description,\n                       coalesce(e.human_readable_id, 0) as human_readable_id,\n                       e.embedding as description_embedding,\n                       text_unit_ids,\n                       community_ids,\n                       relationship_count as rank\n            "
2025-11-18 15:09:36,104 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 6, column: 65, offset: 308} for query: "\n                MATCH (e:__Entity__)\n                OPTIONAL MATCH (c:Chunk)-[:HAS_ENTITY]->(e)\n                WITH e, collect(DISTINCT c.id) as text_unit_ids, count(c) as mention_count\n                WITH e, text_unit_ids, mention_count, \n                     CASE WHEN e.communityId IS NOT NULL THEN e.communityId ELSE [] END as community_ids\n                OPTIONAL MATCH (e)-[r:RELATED_TO]-()\n                WITH e, text_unit_ids, mention_count, community_ids, count(r) as relationship_count\n                RETURN e.id as id,\n                       e.name as title,\n                       coalesce(e.entity_type, [l IN labels(e) WHERE l <> '__Entity__'][0]) as type,\n                       e.description as description,\n                       coalesce(e.human_readable_id, 0) as human_readable_id,\n                       e.embedding as description_embedding,\n                       text_unit_ids,\n                       community_ids,\n                       relationship_count as rank\n            "
2025-11-18 15:09:36,104 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 7, column: 39, offset: 387} for query: "\n                MATCH (e:__Entity__)\n                OPTIONAL MATCH (c:Chunk)-[:HAS_ENTITY]->(e)\n                WITH e, collect(DISTINCT c.id) as text_unit_ids, count(c) as mention_count\n                WITH e, text_unit_ids, mention_count, \n                     CASE WHEN e.communityId IS NOT NULL THEN e.communityId ELSE [] END as community_ids\n                OPTIONAL MATCH (e)-[r:RELATED_TO]-()\n                WITH e, text_unit_ids, mention_count, community_ids, count(r) as relationship_count\n                RETURN e.id as id,\n                       e.name as title,\n                       coalesce(e.entity_type, [l IN labels(e) WHERE l <> '__Entity__'][0]) as type,\n                       e.description as description,\n                       coalesce(e.human_readable_id, 0) as human_readable_id,\n                       e.embedding as description_embedding,\n                       text_unit_ids,\n                       community_ids,\n                       relationship_count as rank\n            "
2025-11-18 15:09:36,105 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:492 - Loaded 181
2025-11-18 15:09:36,236 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: count)} {position: line: 9, column: 35, offset: 455} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:09:36,236 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: confidence)} {position: line: 9, column: 44, offset: 464} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:09:36,237 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: count)} {position: line: 7, column: 35, offset: 306} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:09:36,237 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: confidence)} {position: line: 7, column: 44, offset: 315} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:09:36,237 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 2, column: 42, offset: 42} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:09:36,237 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 10, column: 39, offset: 526} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:09:36,237 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 11, column: 39, offset: 599} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:09:36,237 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: evidence)} {position: line: 6, column: 35, offset: 232} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:09:36,237 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:527 - Loaded 0 relationships
2025-11-18 15:09:36,551 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:559 - Loaded 35 text_units
2025-11-18 15:09:36,660 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: rating_explanation)} {position: line: 7, column: 26, offset: 248} for query: '\n                MATCH (c:__Community__)\n                RETURN c.id as id,\n                       coalesce(c.title, c.id) as title,\n                       c.level as level,\n                       c.community_rank as rank,\n                       c.rating_explanation as rating_explanation,\n                       c.summary as summary,\n                       coalesce(c.weight, 1.0) as weight\n                ORDER BY c.level, c.community_rank DESC\n            '
2025-11-18 15:09:36,661 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:590 - Loaded 267 communities
2025-11-18 15:09:36,732 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: rating_explanation)} {position: line: 9, column: 26, offset: 352} for query: '\n                MATCH (c:__Community__)\n                WHERE c.summary IS NOT NULL\n                RETURN c.id as community_id,\n                       c.summary as full_content,\n                       c.level as level,\n                       c.community_rank as rank,\n                       coalesce(c.title, c.id) as title,\n                       c.rating_explanation as rating_explanation,\n                       c.summary as summary\n                ORDER BY c.level, c.community_rank DESC\n            '
2025-11-18 15:09:36,732 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:622 - Loaded 23 community reports.
2025-11-18 15:09:37,028 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:09:37,162 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 11, column: 43, offset: 565} for query: "\n                    CALL db.index.vector.queryNodes('entity_embedding', $k, $query_embedding)\n                    YIELD node, score\n                    RETURN node.id as id,\n                           node.name as title,\n                           node.entity_type as type,\n                           node.description as description,\n                           node.human_readable_id as human_readable_id,\n                           node.embedding as description_embedding,\n                           [] as text_unit_ids,\n                           CASE WHEN node.communityId IS NOT NULL THEN node.communityId ELSE [] END as community_ids,\n                           coalesce(node.human_readable_id, 0) as rank,\n                           score\n                    ORDER BY score DESC\n                    LIMIT $k\n                "
2025-11-18 15:09:37,162 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 11, column: 77, offset: 599} for query: "\n                    CALL db.index.vector.queryNodes('entity_embedding', $k, $query_embedding)\n                    YIELD node, score\n                    RETURN node.id as id,\n                           node.name as title,\n                           node.entity_type as type,\n                           node.description as description,\n                           node.human_readable_id as human_readable_id,\n                           node.embedding as description_embedding,\n                           [] as text_unit_ids,\n                           CASE WHEN node.communityId IS NOT NULL THEN node.communityId ELSE [] END as community_ids,\n                           coalesce(node.human_readable_id, 0) as rank,\n                           score\n                    ORDER BY score DESC\n                    LIMIT $k\n                "
2025-11-18 15:09:45,626 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:09:51,843 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:09:58,036 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:09:58,543 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2305 - In advanced GraphRAG wit mode = hybrid
2025-11-18 15:10:00,184 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 6, column: 34, offset: 277} for query: "\n                MATCH (e:__Entity__)\n                OPTIONAL MATCH (c:Chunk)-[:HAS_ENTITY]->(e)\n                WITH e, collect(DISTINCT c.id) as text_unit_ids, count(c) as mention_count\n                WITH e, text_unit_ids, mention_count, \n                     CASE WHEN e.communityId IS NOT NULL THEN e.communityId ELSE [] END as community_ids\n                OPTIONAL MATCH (e)-[r:RELATED_TO]-()\n                WITH e, text_unit_ids, mention_count, community_ids, count(r) as relationship_count\n                RETURN e.id as id,\n                       e.name as title,\n                       coalesce(e.entity_type, [l IN labels(e) WHERE l <> '__Entity__'][0]) as type,\n                       e.description as description,\n                       coalesce(e.human_readable_id, 0) as human_readable_id,\n                       e.embedding as description_embedding,\n                       text_unit_ids,\n                       community_ids,\n                       relationship_count as rank\n            "
2025-11-18 15:10:00,185 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 6, column: 65, offset: 308} for query: "\n                MATCH (e:__Entity__)\n                OPTIONAL MATCH (c:Chunk)-[:HAS_ENTITY]->(e)\n                WITH e, collect(DISTINCT c.id) as text_unit_ids, count(c) as mention_count\n                WITH e, text_unit_ids, mention_count, \n                     CASE WHEN e.communityId IS NOT NULL THEN e.communityId ELSE [] END as community_ids\n                OPTIONAL MATCH (e)-[r:RELATED_TO]-()\n                WITH e, text_unit_ids, mention_count, community_ids, count(r) as relationship_count\n                RETURN e.id as id,\n                       e.name as title,\n                       coalesce(e.entity_type, [l IN labels(e) WHERE l <> '__Entity__'][0]) as type,\n                       e.description as description,\n                       coalesce(e.human_readable_id, 0) as human_readable_id,\n                       e.embedding as description_embedding,\n                       text_unit_ids,\n                       community_ids,\n                       relationship_count as rank\n            "
2025-11-18 15:10:00,185 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 7, column: 39, offset: 387} for query: "\n                MATCH (e:__Entity__)\n                OPTIONAL MATCH (c:Chunk)-[:HAS_ENTITY]->(e)\n                WITH e, collect(DISTINCT c.id) as text_unit_ids, count(c) as mention_count\n                WITH e, text_unit_ids, mention_count, \n                     CASE WHEN e.communityId IS NOT NULL THEN e.communityId ELSE [] END as community_ids\n                OPTIONAL MATCH (e)-[r:RELATED_TO]-()\n                WITH e, text_unit_ids, mention_count, community_ids, count(r) as relationship_count\n                RETURN e.id as id,\n                       e.name as title,\n                       coalesce(e.entity_type, [l IN labels(e) WHERE l <> '__Entity__'][0]) as type,\n                       e.description as description,\n                       coalesce(e.human_readable_id, 0) as human_readable_id,\n                       e.embedding as description_embedding,\n                       text_unit_ids,\n                       community_ids,\n                       relationship_count as rank\n            "
2025-11-18 15:10:00,185 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:492 - Loaded 181
2025-11-18 15:10:00,190 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: count)} {position: line: 9, column: 35, offset: 455} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:00,190 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: confidence)} {position: line: 9, column: 44, offset: 464} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:00,190 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: count)} {position: line: 7, column: 35, offset: 306} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:00,190 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: confidence)} {position: line: 7, column: 44, offset: 315} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:00,191 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 2, column: 42, offset: 42} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:00,191 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 10, column: 39, offset: 526} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:00,191 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 11, column: 39, offset: 599} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:00,191 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: evidence)} {position: line: 6, column: 35, offset: 232} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:00,191 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:527 - Loaded 0 relationships
2025-11-18 15:10:00,358 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:559 - Loaded 35 text_units
2025-11-18 15:10:00,398 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: rating_explanation)} {position: line: 7, column: 26, offset: 248} for query: '\n                MATCH (c:__Community__)\n                RETURN c.id as id,\n                       coalesce(c.title, c.id) as title,\n                       c.level as level,\n                       c.community_rank as rank,\n                       c.rating_explanation as rating_explanation,\n                       c.summary as summary,\n                       coalesce(c.weight, 1.0) as weight\n                ORDER BY c.level, c.community_rank DESC\n            '
2025-11-18 15:10:00,399 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:590 - Loaded 267 communities
2025-11-18 15:10:00,410 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: rating_explanation)} {position: line: 9, column: 26, offset: 352} for query: '\n                MATCH (c:__Community__)\n                WHERE c.summary IS NOT NULL\n                RETURN c.id as community_id,\n                       c.summary as full_content,\n                       c.level as level,\n                       c.community_rank as rank,\n                       coalesce(c.title, c.id) as title,\n                       c.rating_explanation as rating_explanation,\n                       c.summary as summary\n                ORDER BY c.level, c.community_rank DESC\n            '
2025-11-18 15:10:00,410 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:622 - Loaded 23 community reports.
2025-11-18 15:10:00,878 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:10:00,910 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 11, column: 43, offset: 565} for query: "\n                    CALL db.index.vector.queryNodes('entity_embedding', $k, $query_embedding)\n                    YIELD node, score\n                    RETURN node.id as id,\n                           node.name as title,\n                           node.entity_type as type,\n                           node.description as description,\n                           node.human_readable_id as human_readable_id,\n                           node.embedding as description_embedding,\n                           [] as text_unit_ids,\n                           CASE WHEN node.communityId IS NOT NULL THEN node.communityId ELSE [] END as community_ids,\n                           coalesce(node.human_readable_id, 0) as rank,\n                           score\n                    ORDER BY score DESC\n                    LIMIT $k\n                "
2025-11-18 15:10:00,910 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 11, column: 77, offset: 599} for query: "\n                    CALL db.index.vector.queryNodes('entity_embedding', $k, $query_embedding)\n                    YIELD node, score\n                    RETURN node.id as id,\n                           node.name as title,\n                           node.entity_type as type,\n                           node.description as description,\n                           node.human_readable_id as human_readable_id,\n                           node.embedding as description_embedding,\n                           [] as text_unit_ids,\n                           CASE WHEN node.communityId IS NOT NULL THEN node.communityId ELSE [] END as community_ids,\n                           coalesce(node.human_readable_id, 0) as rank,\n                           score\n                    ORDER BY score DESC\n                    LIMIT $k\n                "
2025-11-18 15:10:08,431 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:10:14,922 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:10:20,524 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:10:21,037 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:2305 - In advanced GraphRAG wit mode = hybrid
2025-11-18 15:10:22,574 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 6, column: 34, offset: 277} for query: "\n                MATCH (e:__Entity__)\n                OPTIONAL MATCH (c:Chunk)-[:HAS_ENTITY]->(e)\n                WITH e, collect(DISTINCT c.id) as text_unit_ids, count(c) as mention_count\n                WITH e, text_unit_ids, mention_count, \n                     CASE WHEN e.communityId IS NOT NULL THEN e.communityId ELSE [] END as community_ids\n                OPTIONAL MATCH (e)-[r:RELATED_TO]-()\n                WITH e, text_unit_ids, mention_count, community_ids, count(r) as relationship_count\n                RETURN e.id as id,\n                       e.name as title,\n                       coalesce(e.entity_type, [l IN labels(e) WHERE l <> '__Entity__'][0]) as type,\n                       e.description as description,\n                       coalesce(e.human_readable_id, 0) as human_readable_id,\n                       e.embedding as description_embedding,\n                       text_unit_ids,\n                       community_ids,\n                       relationship_count as rank\n            "
2025-11-18 15:10:22,574 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 6, column: 65, offset: 308} for query: "\n                MATCH (e:__Entity__)\n                OPTIONAL MATCH (c:Chunk)-[:HAS_ENTITY]->(e)\n                WITH e, collect(DISTINCT c.id) as text_unit_ids, count(c) as mention_count\n                WITH e, text_unit_ids, mention_count, \n                     CASE WHEN e.communityId IS NOT NULL THEN e.communityId ELSE [] END as community_ids\n                OPTIONAL MATCH (e)-[r:RELATED_TO]-()\n                WITH e, text_unit_ids, mention_count, community_ids, count(r) as relationship_count\n                RETURN e.id as id,\n                       e.name as title,\n                       coalesce(e.entity_type, [l IN labels(e) WHERE l <> '__Entity__'][0]) as type,\n                       e.description as description,\n                       coalesce(e.human_readable_id, 0) as human_readable_id,\n                       e.embedding as description_embedding,\n                       text_unit_ids,\n                       community_ids,\n                       relationship_count as rank\n            "
2025-11-18 15:10:22,574 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 7, column: 39, offset: 387} for query: "\n                MATCH (e:__Entity__)\n                OPTIONAL MATCH (c:Chunk)-[:HAS_ENTITY]->(e)\n                WITH e, collect(DISTINCT c.id) as text_unit_ids, count(c) as mention_count\n                WITH e, text_unit_ids, mention_count, \n                     CASE WHEN e.communityId IS NOT NULL THEN e.communityId ELSE [] END as community_ids\n                OPTIONAL MATCH (e)-[r:RELATED_TO]-()\n                WITH e, text_unit_ids, mention_count, community_ids, count(r) as relationship_count\n                RETURN e.id as id,\n                       e.name as title,\n                       coalesce(e.entity_type, [l IN labels(e) WHERE l <> '__Entity__'][0]) as type,\n                       e.description as description,\n                       coalesce(e.human_readable_id, 0) as human_readable_id,\n                       e.embedding as description_embedding,\n                       text_unit_ids,\n                       community_ids,\n                       relationship_count as rank\n            "
2025-11-18 15:10:22,574 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:492 - Loaded 181
2025-11-18 15:10:22,579 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: count)} {position: line: 9, column: 35, offset: 455} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:22,580 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: confidence)} {position: line: 9, column: 44, offset: 464} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:22,580 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: count)} {position: line: 7, column: 35, offset: 306} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:22,580 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: confidence)} {position: line: 7, column: 44, offset: 315} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:22,580 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 2, column: 42, offset: 42} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:22,580 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 10, column: 39, offset: 526} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:22,580 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: RELATED_TO)} {position: line: 11, column: 39, offset: 599} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:22,580 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: evidence)} {position: line: 6, column: 35, offset: 232} for query: "\n                MATCH (e1:__Entity__)-[r:RELATED_TO]->(e2:__Entity__)\n                RETURN elementId(r) as id,\n                       e1.name as source,\n                       e2.name as target,\n                       coalesce(r.evidence, 'related to') as description,\n                       coalesce(r.count, r.confidence, 1.0) as weight,\n                       coalesce(r.human_readable_id, 0) as human_readable_id,\n                       coalesce(r.count, r.confidence, 1) as rank,\n                       COUNT { (e1)-[:RELATED_TO]-() } as source_degree,\n                       COUNT { (e2)-[:RELATED_TO]-() } as target_degree\n            "
2025-11-18 15:10:22,580 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:527 - Loaded 0 relationships
2025-11-18 15:10:22,735 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:559 - Loaded 35 text_units
2025-11-18 15:10:22,770 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: rating_explanation)} {position: line: 7, column: 26, offset: 248} for query: '\n                MATCH (c:__Community__)\n                RETURN c.id as id,\n                       coalesce(c.title, c.id) as title,\n                       c.level as level,\n                       c.community_rank as rank,\n                       c.rating_explanation as rating_explanation,\n                       c.summary as summary,\n                       coalesce(c.weight, 1.0) as weight\n                ORDER BY c.level, c.community_rank DESC\n            '
2025-11-18 15:10:22,771 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:590 - Loaded 267 communities
2025-11-18 15:10:22,779 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: rating_explanation)} {position: line: 9, column: 26, offset: 352} for query: '\n                MATCH (c:__Community__)\n                WHERE c.summary IS NOT NULL\n                RETURN c.id as community_id,\n                       c.summary as full_content,\n                       c.level as level,\n                       c.community_rank as rank,\n                       coalesce(c.title, c.id) as title,\n                       c.rating_explanation as rating_explanation,\n                       c.summary as summary\n                ORDER BY c.level, c.community_rank DESC\n            '
2025-11-18 15:10:22,779 - INFO - retrievers.advanced_graphrag_retriever - advanced_graphrag_retriever.py:622 - Loaded 23 community reports.
2025-11-18 15:10:23,226 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:10:23,270 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 11, column: 43, offset: 565} for query: "\n                    CALL db.index.vector.queryNodes('entity_embedding', $k, $query_embedding)\n                    YIELD node, score\n                    RETURN node.id as id,\n                           node.name as title,\n                           node.entity_type as type,\n                           node.description as description,\n                           node.human_readable_id as human_readable_id,\n                           node.embedding as description_embedding,\n                           [] as text_unit_ids,\n                           CASE WHEN node.communityId IS NOT NULL THEN node.communityId ELSE [] END as community_ids,\n                           coalesce(node.human_readable_id, 0) as rank,\n                           score\n                    ORDER BY score DESC\n                    LIMIT $k\n                "
2025-11-18 15:10:23,270 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: communityId)} {position: line: 11, column: 77, offset: 599} for query: "\n                    CALL db.index.vector.queryNodes('entity_embedding', $k, $query_embedding)\n                    YIELD node, score\n                    RETURN node.id as id,\n                           node.name as title,\n                           node.entity_type as type,\n                           node.description as description,\n                           node.human_readable_id as human_readable_id,\n                           node.embedding as description_embedding,\n                           [] as text_unit_ids,\n                           CASE WHEN node.communityId IS NOT NULL THEN node.communityId ELSE [] END as community_ids,\n                           coalesce(node.human_readable_id, 0) as rank,\n                           score\n                    ORDER BY score DESC\n                    LIMIT $k\n                "
2025-11-18 15:10:30,380 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:10:36,366 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:10:42,503 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:10:43,329 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:10:49,568 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:10:49,857 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:10:50,737 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:10:55,145 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:10:55,434 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:10:56,219 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:10:58,890 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:10:59,168 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:11:01,351 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:11:01,641 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.FeatureDeprecationWarning} {category: DEPRECATION} {title: This feature is deprecated and will be removed in future versions.} {description: CALL subquery without a variable scope clause is now deprecated. Use CALL () { ... }} {position: line: 3, column: 9, offset: 735} for query: 'CALL () { CALL db.index.vector.queryNodes($vector_index_name, $top_k * $effective_search_ratio, $query_vector) YIELD node, score WITH node, score LIMIT $top_k WITH collect({node:node, score:score}) AS nodes, max(score) AS vector_index_max_score UNWIND nodes AS n RETURN n.node AS node, (n.score / vector_index_max_score) AS score UNION CALL db.index.fulltext.queryNodes($fulltext_index_name, $query_text, {limit: $top_k}) YIELD node, score WITH collect({node:node, score:score}) AS nodes, max(score) AS ft_index_max_score UNWIND nodes AS n RETURN n.node AS node, (n.score / ft_index_max_score) AS score } WITH node, max(score) AS score ORDER BY score DESC LIMIT $top_k \n        // Hybrid search on entities (vector + fulltext)\n        CALL {\n            // Vector search on entity embeddings\n            CALL db.index.vector.queryNodes($vector_index_name, $top_k, $query_vector) \n            YIELD node AS vector_node, score AS vector_score\n            RETURN vector_node AS result_node, vector_score AS search_score\n            UNION\n            // Fulltext search on entity names and descriptions  \n            CALL db.index.fulltext.queryNodes($fulltext_index_name, $query_text)\n            YIELD node AS ft_node, score AS ft_score\n            RETURN ft_node AS result_node, ft_score AS search_score\n        }\n        // Combine and deduplicate results\n        WITH result_node AS node, max(search_score) AS score\n        ORDER BY score DESC\n        LIMIT $top_k\n        \n        // Collect hybrid search results\n        WITH collect(node) AS nodes,\n             avg(score) AS avg_score,\n             collect({id: elementId(node), score: score}) AS metadata\n        \n        // Graph expansion for Local Entity pattern\n        RETURN avg_score AS score, nodes, metadata,\n\n            // Find top co-mentioned chunks\n            collect {\n                UNWIND nodes AS n\n                MATCH (n)<-[:HAS_ENTITY]-(c:Chunk)\n                WITH c, count(distinct n) AS freq\n                RETURN c\n                ORDER BY freq DESC\n                LIMIT 3\n            } AS chunks,\n\n            // Find relevant communities\n            collect {\n                UNWIND nodes AS n\n                OPTIONAL MATCH (n)-[:IN_COMMUNITY]->(comm:__Community__)\n                WITH comm, \n                     coalesce(comm.community_rank, 0) AS rank, \n                     coalesce(comm.weight, 1.0) AS weight\n                WHERE comm IS NOT NULL\n                RETURN comm\n                ORDER BY rank DESC, weight DESC\n                LIMIT 3\n            } AS communities,\n\n            // Find relationships between found entities\n            collect {\n                UNWIND nodes AS n\n                UNWIND nodes AS m\n                MATCH (n)-[r]->(m)\n                WHERE n <> m\n                RETURN DISTINCT r\n            } AS rels,\n\n            // Find outside entities (1-hop neighbors not in initial results)\n            collect {\n                UNWIND nodes AS n\n                MATCH (n)-[r]-(outside_entity:__Entity__)\n                WHERE NOT outside_entity IN nodes\n                WITH outside_entity, collect(distinct r) AS rels, count(*) AS freq\n                ORDER BY freq DESC\n                LIMIT 10\n                WITH collect(outside_entity) AS outsideNodes, apoc.coll.flatten(collect(rels)) AS rels\n                RETURN { nodes: outsideNodes, rels: rels }\n            } AS outside\n        '
2025-11-18 15:11:11,250 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:11:13,693 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:11:13,814 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.FeatureDeprecationWarning} {category: DEPRECATION} {title: This feature is deprecated and will be removed in future versions.} {description: CALL subquery without a variable scope clause is now deprecated. Use CALL () { ... }} {position: line: 3, column: 9, offset: 735} for query: 'CALL () { CALL db.index.vector.queryNodes($vector_index_name, $top_k * $effective_search_ratio, $query_vector) YIELD node, score WITH node, score LIMIT $top_k WITH collect({node:node, score:score}) AS nodes, max(score) AS vector_index_max_score UNWIND nodes AS n RETURN n.node AS node, (n.score / vector_index_max_score) AS score UNION CALL db.index.fulltext.queryNodes($fulltext_index_name, $query_text, {limit: $top_k}) YIELD node, score WITH collect({node:node, score:score}) AS nodes, max(score) AS ft_index_max_score UNWIND nodes AS n RETURN n.node AS node, (n.score / ft_index_max_score) AS score } WITH node, max(score) AS score ORDER BY score DESC LIMIT $top_k \n        // Hybrid search on entities (vector + fulltext)\n        CALL {\n            // Vector search on entity embeddings\n            CALL db.index.vector.queryNodes($vector_index_name, $top_k, $query_vector) \n            YIELD node AS vector_node, score AS vector_score\n            RETURN vector_node AS result_node, vector_score AS search_score\n            UNION\n            // Fulltext search on entity names and descriptions  \n            CALL db.index.fulltext.queryNodes($fulltext_index_name, $query_text)\n            YIELD node AS ft_node, score AS ft_score\n            RETURN ft_node AS result_node, ft_score AS search_score\n        }\n        // Combine and deduplicate results\n        WITH result_node AS node, max(search_score) AS score\n        ORDER BY score DESC\n        LIMIT $top_k\n        \n        // Collect hybrid search results\n        WITH collect(node) AS nodes,\n             avg(score) AS avg_score,\n             collect({id: elementId(node), score: score}) AS metadata\n        \n        // Graph expansion for Local Entity pattern\n        RETURN avg_score AS score, nodes, metadata,\n\n            // Find top co-mentioned chunks\n            collect {\n                UNWIND nodes AS n\n                MATCH (n)<-[:HAS_ENTITY]-(c:Chunk)\n                WITH c, count(distinct n) AS freq\n                RETURN c\n                ORDER BY freq DESC\n                LIMIT 3\n            } AS chunks,\n\n            // Find relevant communities\n            collect {\n                UNWIND nodes AS n\n                OPTIONAL MATCH (n)-[:IN_COMMUNITY]->(comm:__Community__)\n                WITH comm, \n                     coalesce(comm.community_rank, 0) AS rank, \n                     coalesce(comm.weight, 1.0) AS weight\n                WHERE comm IS NOT NULL\n                RETURN comm\n                ORDER BY rank DESC, weight DESC\n                LIMIT 3\n            } AS communities,\n\n            // Find relationships between found entities\n            collect {\n                UNWIND nodes AS n\n                UNWIND nodes AS m\n                MATCH (n)-[r]->(m)\n                WHERE n <> m\n                RETURN DISTINCT r\n            } AS rels,\n\n            // Find outside entities (1-hop neighbors not in initial results)\n            collect {\n                UNWIND nodes AS n\n                MATCH (n)-[r]-(outside_entity:__Entity__)\n                WHERE NOT outside_entity IN nodes\n                WITH outside_entity, collect(distinct r) AS rels, count(*) AS freq\n                ORDER BY freq DESC\n                LIMIT 10\n                WITH collect(outside_entity) AS outsideNodes, apoc.coll.flatten(collect(rels)) AS rels\n                RETURN { nodes: outsideNodes, rels: rels }\n            } AS outside\n        '
2025-11-18 15:11:37,096 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:11:39,294 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:11:39,352 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.FeatureDeprecationWarning} {category: DEPRECATION} {title: This feature is deprecated and will be removed in future versions.} {description: CALL subquery without a variable scope clause is now deprecated. Use CALL () { ... }} {position: line: 3, column: 9, offset: 735} for query: 'CALL () { CALL db.index.vector.queryNodes($vector_index_name, $top_k * $effective_search_ratio, $query_vector) YIELD node, score WITH node, score LIMIT $top_k WITH collect({node:node, score:score}) AS nodes, max(score) AS vector_index_max_score UNWIND nodes AS n RETURN n.node AS node, (n.score / vector_index_max_score) AS score UNION CALL db.index.fulltext.queryNodes($fulltext_index_name, $query_text, {limit: $top_k}) YIELD node, score WITH collect({node:node, score:score}) AS nodes, max(score) AS ft_index_max_score UNWIND nodes AS n RETURN n.node AS node, (n.score / ft_index_max_score) AS score } WITH node, max(score) AS score ORDER BY score DESC LIMIT $top_k \n        // Hybrid search on entities (vector + fulltext)\n        CALL {\n            // Vector search on entity embeddings\n            CALL db.index.vector.queryNodes($vector_index_name, $top_k, $query_vector) \n            YIELD node AS vector_node, score AS vector_score\n            RETURN vector_node AS result_node, vector_score AS search_score\n            UNION\n            // Fulltext search on entity names and descriptions  \n            CALL db.index.fulltext.queryNodes($fulltext_index_name, $query_text)\n            YIELD node AS ft_node, score AS ft_score\n            RETURN ft_node AS result_node, ft_score AS search_score\n        }\n        // Combine and deduplicate results\n        WITH result_node AS node, max(search_score) AS score\n        ORDER BY score DESC\n        LIMIT $top_k\n        \n        // Collect hybrid search results\n        WITH collect(node) AS nodes,\n             avg(score) AS avg_score,\n             collect({id: elementId(node), score: score}) AS metadata\n        \n        // Graph expansion for Local Entity pattern\n        RETURN avg_score AS score, nodes, metadata,\n\n            // Find top co-mentioned chunks\n            collect {\n                UNWIND nodes AS n\n                MATCH (n)<-[:HAS_ENTITY]-(c:Chunk)\n                WITH c, count(distinct n) AS freq\n                RETURN c\n                ORDER BY freq DESC\n                LIMIT 3\n            } AS chunks,\n\n            // Find relevant communities\n            collect {\n                UNWIND nodes AS n\n                OPTIONAL MATCH (n)-[:IN_COMMUNITY]->(comm:__Community__)\n                WITH comm, \n                     coalesce(comm.community_rank, 0) AS rank, \n                     coalesce(comm.weight, 1.0) AS weight\n                WHERE comm IS NOT NULL\n                RETURN comm\n                ORDER BY rank DESC, weight DESC\n                LIMIT 3\n            } AS communities,\n\n            // Find relationships between found entities\n            collect {\n                UNWIND nodes AS n\n                UNWIND nodes AS m\n                MATCH (n)-[r]->(m)\n                WHERE n <> m\n                RETURN DISTINCT r\n            } AS rels,\n\n            // Find outside entities (1-hop neighbors not in initial results)\n            collect {\n                UNWIND nodes AS n\n                MATCH (n)-[r]-(outside_entity:__Entity__)\n                WHERE NOT outside_entity IN nodes\n                WITH outside_entity, collect(distinct r) AS rels, count(*) AS freq\n                ORDER BY freq DESC\n                LIMIT 10\n                WITH collect(outside_entity) AS outsideNodes, apoc.coll.flatten(collect(rels)) AS rels\n                RETURN { nodes: outsideNodes, rels: rels }\n            } AS outside\n        '
2025-11-18 15:11:50,415 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:11:54,217 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:11:54,798 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:11:55,504 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:11:55,797 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:11:56,429 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:11:56,466 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:11:56,508 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:11:57,913 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:00,450 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:02,396 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:03,568 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:04,962 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:06,739 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:09,619 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:11,240 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:12,761 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:13,172 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:14,518 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:19,070 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:19,755 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:22,782 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:29,013 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:29,219 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:30,143 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:30,729 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:32,006 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:32,145 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:38,065 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:50,548 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:53,474 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:12:55,930 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:13:02,399 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:13:04,298 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:13:16,999 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:13:36,458 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:13:38,186 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:13:45,854 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:24,160 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[1]: TimeoutError()
2025-11-18 15:15:24,161 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[8]: TimeoutError()
2025-11-18 15:15:25,737 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:25,777 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:27,299 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:27,700 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:29,296 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:29,520 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:29,724 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:31,527 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:31,809 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:32,863 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:33,018 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:33,733 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:37,147 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:56,653 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:57,340 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:58,892 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:58,994 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:15:59,548 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:00,343 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:06,308 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:10,782 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:12,263 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 500 Internal Server Error"
2025-11-18 15:16:12,267 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[6]: InternalServerError(Error code: 500 - {'error': {'code': 500, 'message': 'The server had an error processing your request. Sorry about that! You can retry your request, or contact support@openai.com if you keep seeing this error.', 'param': None, 'type': 'cr_error'}})
2025-11-18 15:16:17,503 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:18,828 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:22,950 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:27,523 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:29,623 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:30,243 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:31,510 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:54,296 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:16:56,735 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:17:09,823 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:17:14,642 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:17:22,962 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:17:25,211 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:17:34,197 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:17:43,595 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:17:45,961 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:17:47,357 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:17:55,400 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:11,872 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[1]: TimeoutError()
2025-11-18 15:19:17,479 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:17,509 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:17,594 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:17,826 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:18,196 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:18,546 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:19,593 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:21,327 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:24,524 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:32,995 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:33,167 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:35,796 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:37,825 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:39,165 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:41,190 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:47,157 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:48,297 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:50,921 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:51,360 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:54,353 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:19:57,643 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:04,695 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:04,978 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:11,903 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:15,821 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:18,345 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:19,438 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:19,933 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:49,494 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:51,716 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:57,984 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:59,565 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:20:59,652 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:21:09,645 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:21:21,382 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:21:25,813 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:21:27,927 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:21:32,469 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:21:39,104 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:22:59,035 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[1]: TimeoutError()
2025-11-18 15:22:59,036 - ERROR - ragas.executor - executor.py:104 - Exception raised in Job[0]: TimeoutError()
2025-11-18 15:47:16,641 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:47:17,409 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:47:19,440 - ERROR - chromadb.telemetry.product.posthog - posthog.py:61 - Failed to send telemetry event ClientStartEvent: capture() takes 1 positional argument but 3 were given
2025-11-18 15:47:25,281 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:56 - GraphDatabase driver setup. Database is: neo4j_db
2025-11-18 15:47:26,325 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,337 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,349 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,364 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,376 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,389 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,400 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,413 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,428 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 15:47:26,428 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,449 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 15:47:26,449 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,471 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 15:47:26,472 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,494 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 15:47:26,494 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 15:47:26,502 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:261 - Database schema setup complete
2025-11-18 15:47:26,502 - INFO - data_processors.build_graph.main_processor - main_processor.py:60 - Enhanced CustomGraphProcessor initialized
2025-11-18 15:47:26,503 - INFO - data_processors.build_graph.main_processor - main_processor.py:65 - Relationship strategy: smart
2025-11-18 15:47:33,708 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:47:37,790 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:47:41,682 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:47:42,337 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:47:44,142 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:47:49,985 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:47:50,636 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:47:52,651 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:48:06,187 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:48:19,152 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:48:33,443 - INFO - retrievers.graph_rag_retriever - graph_rag_retriever.py:58 - üîç Executing GraphRAG query for: Across all three RFPs, list the top five digital capabilities the companies demand and explain why those capabilities matter to their industries.
2025-11-18 15:48:34,347 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:48:40,345 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:48:48,627 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:48:50,246 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:48:54,399 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:49:19,248 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:49:21,641 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:49:29,581 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:49:39,682 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:49:54,682 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:50:09,072 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:50:09,176 - WARNING - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.FeatureDeprecationWarning} {category: DEPRECATION} {title: This feature is deprecated and will be removed in future versions.} {description: CALL subquery without a variable scope clause is now deprecated. Use CALL () { ... }} {position: line: 3, column: 9, offset: 735} for query: 'CALL () { CALL db.index.vector.queryNodes($vector_index_name, $top_k * $effective_search_ratio, $query_vector) YIELD node, score WITH node, score LIMIT $top_k WITH collect({node:node, score:score}) AS nodes, max(score) AS vector_index_max_score UNWIND nodes AS n RETURN n.node AS node, (n.score / vector_index_max_score) AS score UNION CALL db.index.fulltext.queryNodes($fulltext_index_name, $query_text, {limit: $top_k}) YIELD node, score WITH collect({node:node, score:score}) AS nodes, max(score) AS ft_index_max_score UNWIND nodes AS n RETURN n.node AS node, (n.score / ft_index_max_score) AS score } WITH node, max(score) AS score ORDER BY score DESC LIMIT $top_k \n        // Hybrid search on entities (vector + fulltext)\n        CALL {\n            // Vector search on entity embeddings\n            CALL db.index.vector.queryNodes($vector_index_name, $top_k, $query_vector) \n            YIELD node AS vector_node, score AS vector_score\n            RETURN vector_node AS result_node, vector_score AS search_score\n            UNION\n            // Fulltext search on entity names and descriptions  \n            CALL db.index.fulltext.queryNodes($fulltext_index_name, $query_text)\n            YIELD node AS ft_node, score AS ft_score\n            RETURN ft_node AS result_node, ft_score AS search_score\n        }\n        // Combine and deduplicate results\n        WITH result_node AS node, max(search_score) AS score\n        ORDER BY score DESC\n        LIMIT $top_k\n        \n        // Collect hybrid search results\n        WITH collect(node) AS nodes,\n             avg(score) AS avg_score,\n             collect({id: elementId(node), score: score}) AS metadata\n        \n        // Graph expansion for Local Entity pattern\n        RETURN avg_score AS score, nodes, metadata,\n\n            // Find top co-mentioned chunks\n            collect {\n                UNWIND nodes AS n\n                MATCH (n)<-[:HAS_ENTITY]-(c:Chunk)\n                WITH c, count(distinct n) AS freq\n                RETURN c\n                ORDER BY freq DESC\n                LIMIT 3\n            } AS chunks,\n\n            // Find relevant communities\n            collect {\n                UNWIND nodes AS n\n                OPTIONAL MATCH (n)-[:IN_COMMUNITY]->(comm:__Community__)\n                WITH comm, \n                     coalesce(comm.community_rank, 0) AS rank, \n                     coalesce(comm.weight, 1.0) AS weight\n                WHERE comm IS NOT NULL\n                RETURN comm\n                ORDER BY rank DESC, weight DESC\n                LIMIT 3\n            } AS communities,\n\n            // Find relationships between found entities\n            collect {\n                UNWIND nodes AS n\n                UNWIND nodes AS m\n                MATCH (n)-[r]->(m)\n                WHERE n <> m\n                RETURN DISTINCT r\n            } AS rels,\n\n            // Find outside entities (1-hop neighbors not in initial results)\n            collect {\n                UNWIND nodes AS n\n                MATCH (n)-[r]-(outside_entity:__Entity__)\n                WHERE NOT outside_entity IN nodes\n                WITH outside_entity, collect(distinct r) AS rels, count(*) AS freq\n                ORDER BY freq DESC\n                LIMIT 10\n                WITH collect(outside_entity) AS outsideNodes, apoc.coll.flatten(collect(rels)) AS rels\n                RETURN { nodes: outsideNodes, rels: rels }\n            } AS outside\n        '
2025-11-18 15:50:19,805 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:50:27,378 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:50:34,701 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:50:53,166 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:51:43,138 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:52:00,952 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:52:03,649 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:52:13,656 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:52:52,047 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 15:53:06,697 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 200 OK"
2025-11-18 15:53:20,790 - INFO - httpx - _client.py:1025 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:53:28,531 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:53:34,773 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:53:34,904 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:54:14,152 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:54:16,483 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:54:23,703 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 15:54:25,314 - INFO - httpx - _client.py:1740 - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-11-18 16:24:43,583 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 16:24:47,943 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:56 - GraphDatabase driver setup. Database is: neo4j_db
2025-11-18 16:25:41,251 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 16:25:45,491 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:56 - GraphDatabase driver setup. Database is: neo4j_db
2025-11-18 16:25:46,147 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,154 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,160 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,167 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,174 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,180 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,188 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,192 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,197 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 16:25:46,197 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,205 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 16:25:46,205 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,214 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 16:25:46,214 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,222 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 16:25:46,222 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:25:46,225 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:261 - Database schema setup complete
2025-11-18 16:26:57,585 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 16:27:01,641 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:56 - GraphDatabase driver setup. Database is: neo4j_db
2025-11-18 16:27:02,298 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,305 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,310 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,318 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,323 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,329 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,335 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,340 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,344 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 16:27:02,345 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,351 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 16:27:02,351 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,357 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 16:27:02,357 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,366 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 16:27:02,367 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:02,369 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:261 - Database schema setup complete
2025-11-18 16:27:02,369 - INFO - data_processors.build_graph.main_processor - main_processor.py:60 - Enhanced CustomGraphProcessor initialized
2025-11-18 16:27:02,369 - INFO - data_processors.build_graph.main_processor - main_processor.py:65 - Relationship strategy: smart
2025-11-18 16:27:12,772 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 16:27:17,143 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:56 - GraphDatabase driver setup. Database is: neo4j_db
2025-11-18 16:27:17,816 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:17,821 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:27:17,829 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 16:59:56,856 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 17:00:03,069 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:56 - GraphDatabase driver setup. Database is: neo4j_db
2025-11-18 17:00:05,112 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,124 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,138 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,149 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:194 - Unable to create constraint. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,162 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,175 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,188 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,202 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:211 - Unable to create  full-text search indexes. None. Failed with exception {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,214 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 17:00:05,214 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,236 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 17:00:05,236 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,258 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 17:00:05,259 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,281 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 17:00:05,281 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Database.DatabaseNotFound} {message: Unable to get a routing table for database 'neo4j_db' because this database does not exist}
2025-11-18 17:00:05,289 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:261 - Database schema setup complete
2025-11-18 17:00:05,289 - INFO - data_processors.build_graph.main_processor - main_processor.py:60 - Enhanced CustomGraphProcessor initialized
2025-11-18 17:00:05,289 - INFO - data_processors.build_graph.main_processor - main_processor.py:65 - Relationship strategy: smart
2025-11-18 17:01:47,791 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 17:01:52,528 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:56 - GraphDatabase driver setup. Database is: neo4j
2025-11-18 17:01:53,461 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE CONSTRAINT document_id IF NOT EXISTS FOR (e:Document) REQUIRE (e.id) IS UNIQUE` has no effect.} {description: `CONSTRAINT doc_id FOR (e:Document) REQUIRE (e.id) IS UNIQUE` already exists.} {position: None} for query: 'CREATE CONSTRAINT document_id IF NOT EXISTS FOR (d:Document) REQUIRE d.id IS UNIQUE'
2025-11-18 17:01:53,484 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE CONSTRAINT chunk_id IF NOT EXISTS FOR (e:Chunk) REQUIRE (e.id) IS UNIQUE` has no effect.} {description: `CONSTRAINT chunk_id FOR (e:Chunk) REQUIRE (e.id) IS UNIQUE` already exists.} {position: None} for query: 'CREATE CONSTRAINT chunk_id IF NOT EXISTS FOR (c:Chunk) REQUIRE c.id IS UNIQUE'
2025-11-18 17:01:53,647 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:Entity) REQUIRE (e.id) IS UNIQUE` has no effect.} {description: `CONSTRAINT entity_id FOR (e:__Entity__) REQUIRE (e.id) IS UNIQUE` already exists.} {position: None} for query: 'CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:Entity) REQUIRE e.id IS UNIQUE'
2025-11-18 17:01:53,665 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:__Entity__) REQUIRE (e.id) IS UNIQUE` has no effect.} {description: `CONSTRAINT entity_id FOR (e:__Entity__) REQUIRE (e.id) IS UNIQUE` already exists.} {position: None} for query: 'CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:__Entity__) REQUIRE e.id IS UNIQUE'
2025-11-18 17:01:53,867 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX chunk_text_index IF NOT EXISTS FOR (e:Chunk) ON EACH [e.text]` has no effect.} {description: `FULLTEXT INDEX chunk_text_fulltext FOR (e:Chunk) ON EACH [e.text]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX chunk_text_index IF NOT EXISTS FOR (c:Chunk) ON EACH [c.text]'
2025-11-18 17:01:53,888 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX entity_fulltext_idx IF NOT EXISTS FOR (e:__Entity__) ON EACH [e.name, e.description]` has no effect.} {description: `FULLTEXT INDEX entity_fulltext_idx FOR (e:__Entity__) ON EACH [e.name, e.description]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX entity_fulltext_idx IF NOT EXISTS FOR (e:__Entity__) ON EACH [e.name, e.description]'
2025-11-18 17:01:53,907 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX chunk_text_fulltext IF NOT EXISTS FOR (e:Chunk) ON EACH [e.text]` has no effect.} {description: `FULLTEXT INDEX chunk_text_fulltext FOR (e:Chunk) ON EACH [e.text]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX chunk_text_fulltext IF NOT EXISTS FOR (c:Chunk) ON EACH [c.text]'
2025-11-18 17:01:54,114 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 17:01:54,114 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Schema.IndexAlreadyExists} {message: There already exists an index (:Document {embedding}).}
2025-11-18 17:01:54,154 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 17:01:54,154 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Schema.IndexAlreadyExists} {message: There already exists an index (:Chunk {embedding}).}
2025-11-18 17:01:54,238 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 17:01:54,239 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Schema.IndexAlreadyExists} {message: There already exists an index (:__Entity__ {embedding}).}
2025-11-18 17:01:54,240 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:261 - Database schema setup complete
2025-11-18 17:01:54,240 - INFO - data_processors.build_graph.main_processor - main_processor.py:60 - Enhanced CustomGraphProcessor initialized
2025-11-18 17:01:54,240 - INFO - data_processors.build_graph.main_processor - main_processor.py:65 - Relationship strategy: smart
2025-11-18 17:03:04,500 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 17:03:09,292 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:56 - GraphDatabase driver setup. Database is: neo4j
2025-11-18 17:03:10,062 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE CONSTRAINT document_id IF NOT EXISTS FOR (e:Document) REQUIRE (e.id) IS UNIQUE` has no effect.} {description: `CONSTRAINT doc_id FOR (e:Document) REQUIRE (e.id) IS UNIQUE` already exists.} {position: None} for query: 'CREATE CONSTRAINT document_id IF NOT EXISTS FOR (d:Document) REQUIRE d.id IS UNIQUE'
2025-11-18 17:03:10,075 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE CONSTRAINT chunk_id IF NOT EXISTS FOR (e:Chunk) REQUIRE (e.id) IS UNIQUE` has no effect.} {description: `CONSTRAINT chunk_id FOR (e:Chunk) REQUIRE (e.id) IS UNIQUE` already exists.} {position: None} for query: 'CREATE CONSTRAINT chunk_id IF NOT EXISTS FOR (c:Chunk) REQUIRE c.id IS UNIQUE'
2025-11-18 17:03:10,089 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:Entity) REQUIRE (e.id) IS UNIQUE` has no effect.} {description: `CONSTRAINT entity_id FOR (e:__Entity__) REQUIRE (e.id) IS UNIQUE` already exists.} {position: None} for query: 'CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:Entity) REQUIRE e.id IS UNIQUE'
2025-11-18 17:03:10,103 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:__Entity__) REQUIRE (e.id) IS UNIQUE` has no effect.} {description: `CONSTRAINT entity_id FOR (e:__Entity__) REQUIRE (e.id) IS UNIQUE` already exists.} {position: None} for query: 'CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:__Entity__) REQUIRE e.id IS UNIQUE'
2025-11-18 17:03:10,115 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX entity_text_index IF NOT EXISTS FOR (e:Entity) ON EACH [e.text]` has no effect.} {description: `FULLTEXT INDEX entity_text_index FOR (e:Entity) ON EACH [e.text]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX entity_text_index IF NOT EXISTS FOR (e:Entity) ON EACH [e.text]'
2025-11-18 17:03:10,128 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX chunk_text_index IF NOT EXISTS FOR (e:Chunk) ON EACH [e.text]` has no effect.} {description: `FULLTEXT INDEX chunk_text_fulltext FOR (e:Chunk) ON EACH [e.text]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX chunk_text_index IF NOT EXISTS FOR (c:Chunk) ON EACH [c.text]'
2025-11-18 17:03:10,142 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX entity_fulltext_idx IF NOT EXISTS FOR (e:__Entity__) ON EACH [e.name, e.description]` has no effect.} {description: `FULLTEXT INDEX entity_fulltext_idx FOR (e:__Entity__) ON EACH [e.name, e.description]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX entity_fulltext_idx IF NOT EXISTS FOR (e:__Entity__) ON EACH [e.name, e.description]'
2025-11-18 17:03:10,156 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX chunk_text_fulltext IF NOT EXISTS FOR (e:Chunk) ON EACH [e.text]` has no effect.} {description: `FULLTEXT INDEX chunk_text_fulltext FOR (e:Chunk) ON EACH [e.text]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX chunk_text_fulltext IF NOT EXISTS FOR (c:Chunk) ON EACH [c.text]'
2025-11-18 17:03:10,178 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 17:03:10,178 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Schema.IndexAlreadyExists} {message: There already exists an index (:Document {embedding}).}
2025-11-18 17:03:10,195 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 17:03:10,195 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Schema.IndexAlreadyExists} {message: There already exists an index (:Chunk {embedding}).}
2025-11-18 17:03:10,215 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 17:03:10,215 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Schema.EquivalentSchemaRuleAlreadyExists} {message: An equivalent index already exists, 'Index( id=39, name='entity_embeddings_old', type='VECTOR', schema=(:Entity {embedding}), indexProvider='vector-2.0' )'.}
2025-11-18 17:03:10,233 - ERROR - data_processors.build_graph.graph_operations - graph_operations.py:256 - Unable to create index: None
2025-11-18 17:03:10,234 - WARNING - data_processors.build_graph.graph_operations - graph_operations.py:257 - Vector index may already exist: {code: Neo.ClientError.Schema.IndexAlreadyExists} {message: There already exists an index (:__Entity__ {embedding}).}
2025-11-18 17:03:10,235 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:261 - Database schema setup complete
2025-11-18 17:03:10,236 - INFO - data_processors.build_graph.main_processor - main_processor.py:60 - Enhanced CustomGraphProcessor initialized
2025-11-18 17:03:10,236 - INFO - data_processors.build_graph.main_processor - main_processor.py:65 - Relationship strategy: smart
2025-11-18 17:03:14,708 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:81 - GraphDatabase driver setup. Dropping vector indices
2025-11-18 17:04:21,114 - INFO - utils.llms - llms.py:90 - VertexAI not available, skipping VertexAI-specific initialization
2025-11-18 17:04:25,616 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:56 - GraphDatabase driver setup. Database is: neo4j
2025-11-18 17:04:26,641 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:__Entity__) REQUIRE (e.id) IS UNIQUE` has no effect.} {description: `CONSTRAINT entity_id FOR (e:Entity) REQUIRE (e.id) IS UNIQUE` already exists.} {position: None} for query: 'CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:__Entity__) REQUIRE e.id IS UNIQUE'
2025-11-18 17:04:27,016 - INFO - neo4j.notifications - result.py:337 - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX chunk_text_fulltext IF NOT EXISTS FOR (e:Chunk) ON EACH [e.text]` has no effect.} {description: `FULLTEXT INDEX chunk_text_index FOR (e:Chunk) ON EACH [e.text]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX chunk_text_fulltext IF NOT EXISTS FOR (c:Chunk) ON EACH [c.text]'
2025-11-18 17:04:27,398 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:261 - Database schema setup complete
2025-11-18 17:04:27,398 - INFO - data_processors.build_graph.main_processor - main_processor.py:60 - Enhanced CustomGraphProcessor initialized
2025-11-18 17:04:27,398 - INFO - data_processors.build_graph.main_processor - main_processor.py:65 - Relationship strategy: smart
2025-11-18 17:04:31,357 - INFO - data_processors.build_graph.graph_operations - graph_operations.py:81 - GraphDatabase driver setup. Dropping vector indices
